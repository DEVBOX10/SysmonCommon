<#@ template language="C#" hostspecific="true" #>
<#@ output encoding="utf-16" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#
	//
	// This T4 template is able to generate .mc, .man and header files based on the target version (internal, shared, public)
	// Data is pulled from manifest.xml and arguments from TextTransform allow to generate the right file.
	//
	string type = Host.ResolveParameterValue("", "", "type").ToLower();
	XmlDocument doc = new XmlDocument();
	doc.Load(Host.ResolvePath("manifest.xml"));
	XmlNodeList manifests = doc.SelectNodes(@"//manifest");

	var fieldHashDict = new Dictionary<string, int>();
	var manDict = new Dictionary<double, XmlNode>();
	double highest = 0;
	double highestBinary = 0;
	
	// Find the highest version manifest
	foreach (XmlNode m in manifests) {
	
		if (m.Attributes["schemaversion"] == null || m.Attributes["binaryversion"] == null) {
			throw new Exception("One manifest entry misses a schemaversion or binaryversion number");
		}
		
		var v = double.Parse(m.Attributes["schemaversion"].Value);
		var b = double.Parse(m.Attributes["binaryversion"].Value);
		
		if (manDict.ContainsKey(v)) {
			throw new Exception("Multiple manifest with same schemaversion number");
		}
		
		manDict[v] = m;
		
		if (v > highest) {
			highest = v;
		}
		if (b > highestBinary) {
			highestBinary = b;
		}
	}
	
	var highestBase = Math.Round(highest);
	if (highestBase > highest) highestBase -= 1.0;
	XmlNode man = manDict[highest];
	
	XmlNodeList eventNodes = man.SelectNodes(@".//event");
	if (type == "header") {
#>
//====================================================================
//
// Sysmonevents.h
//
// Copyright (C) 2014 Mark Russinovich and Thomas Garnier
//
// Sysmon events information header, generated by T4 template.
// DO NOT EDIT DIRECTLY. MAKE CHANGES TO MANIFEST.TT.
//
//====================================================================

#pragma once
#ifndef SYSMON_DRIVER
#ifndef SYSMON_EBPF
#if defined _WIN64 || defined _WIN32
#include "..\sysmonCommon\stdafx.h"
#else
#include "stdafx.h"
#endif
#endif
#if defined(SYSMON_SHARED)
#include "sysmonmsg_shared.h"
#include "sysmonmsgop_shared.h"
#elif defined(SYSMON_PUBLIC)
#include "sysmonmsg_public.h"
#include "sysmonmsgop_public.h"
#else
#include "sysmonmsg.h"
#include "sysmonmsgop.h"
#endif
#else
#include <fltkernel.h>

#define _T(_x) L ## _x
#if !defined(_countof)
#define _countof(_x) (sizeof(_x)/sizeof(*_x))
#endif
#define _tcsicmp _wcsicmp
#endif

#if defined _WIN64 || defined _WIN32
#define STRCASECMP(a,b) _stricmp(a,b)
#elif defined __linux__
#define STRCASECMP(a,b) strcasecmp(a,b)
#endif

//
// Types submitted to the engine
//
typedef enum {
	N_Invalid = 0,
	N_UnicodeString,
	N_EscapeUnicodeString,
	N_AnsiOrUnicodeString,
	N_UnicodePath,
	N_Ptr,
	N_Ulong,
	N_Ulong64,
	N_LargeTime,
	N_ProcessId,
	N_LogonId,
	N_Sid,
	N_Hash,
	N_GUID,
	N_CallTrace,
	N_RegistryPath,
    N_LinuxCommandLine
} NativeTypes;

//
// Types expected by the Vista+ event manager
//
typedef enum {
	I_UnicodeString,
	I_GUID,
	I_UInt64,
	I_UInt32,
	I_UInt16,
	I_HexInt64,
	I_HexInt32,
	I_Boolean
} InTypes;

typedef enum {
	Rule_include = 0,
	Rule_exclude,
	Rule_include_partial,
	Rule_exclude_partial,
	Rule_Unknown = -1
} RuleDefaultType;

typedef enum {
	RuleCombineOR = 0,
	RuleCombineAND = 1,
	RuleCombineDefault = 0
}  RuleCombineType, *PRuleCombineType;

//
// Describe an event structure
//
typedef struct {
	USHORT					FieldCount;
	NTSTATUS				EventLegacyId;
	const EVENT_DESCRIPTOR* EventDescriptor;
	ULONG					EventId;
	PTCHAR					EventName;
	PTCHAR					EventDescription;
	InTypes*				EventOutputTypes;
	PTCHAR*					FieldNames;
	ULONG					EventTimeField;
	PTCHAR					RuleName;
	RuleDefaultType				Default;
	PULONG					FieldHashes;
} SYSMON_EVENT_TYPE_FMT, *PSYSMON_EVENT_TYPE_FMT;

#define NO_FIELD ((ULONG)-1)

//
// Describe entry awaiting processing
//
typedef struct {
	NativeTypes Type;
	PVOID		Ptr;
	ULONG		Size;
	BOOLEAN		Allocated;
} SYSMON_DATA_DESCRIPTOR, *PSYSMON_DATA_DESCRIPTOR;

<#
	int padding = 40;
	int maxfields = 0;
	int maxid = 0;

	var eventIdTableDict = new Dictionary<int, string>();

	foreach (XmlNode e in eventNodes)
	{
		var i = OutputIfDef(e);

		// All identifiers should be integers, don't assume sequence.
		// Ignore error ID that was 255 (first one).
		var id = Int32.Parse(e.Attributes["value"].Value);
		if (id > maxid && id != 255) {
			maxid = id;
		}

		if (i != "") {
#>

#if <#= i #>
<#
		} else { 
#>

<#
		}

		var name = e.Attributes["name"].Value;
		var accro = GetAcro(e);

		if (eventIdTableDict.ContainsKey(id)) {
			throw new Exception("Two entries have same identifier");
		}

		eventIdTableDict[id] = name;

#>
//
// <#= name #> event
//
<#
		XmlNodeList sub = e.SelectNodes(@".//data");
		int index = 0;
		bool timeField = false;
		foreach(XmlNode s in sub)
		{
			var s_name = s.Attributes["name"].Value;
			
			if (s_name == "UtcTime") {
				timeField = true;
			}
			
#>
#define <#= String.Format("{0}_{1,-"+(padding - accro.Length).ToString()+"} {2,2} // Type: {3}", accro, s_name, index, GetInType(s)) #>
<#
			index++;
		}
		
		if (index > maxfields)
			maxfields = index;
#>
#define <#= String.Format("{0}_{1,-"+(padding - name.Length).ToString()+"} {2,2}", name, "Count", index) #>

#if !defined(SYSMON_EVENT_C)
extern SYSMON_EVENT_TYPE_FMT <#= name #>_Type;
#else
InTypes <#= name #>_type_list[] = {
<#
	foreach(XmlNode s in sub) {
#>
	I_<#= GetInType(s) #>,
<#
	}
#>
};
PTCHAR <#= name #>_FieldNames[] = {
<#
	foreach(XmlNode s in sub) {
#>
	_T("<#= s.Attributes["name"].Value #>"),
<#
	}
#>
};
ULONG <#= name #>_FieldHashes[] = {
<#
	foreach(XmlNode s in sub) {

		// GetHashCode is not documented, check that each value is unique per string.
		// Aka no collision.
		string k = s.Attributes["name"].Value;
		int hashCode = k.GetHashCode();
		if (fieldHashDict.ContainsKey(k) && fieldHashDict[k] != hashCode) {
			throw new Exception("Two fields with same string and different hashCode");
		}
		fieldHashDict[k] = hashCode;
#>
	0x<#= Convert.ToString(hashCode, 16) #>,
<#
	}
#>
};

SYSMON_EVENT_TYPE_FMT <#= name #>_Type = {
	<#= name #>_Count,
#if !defined(SYSMON_DRIVER)	
	<#= name #>,
	&<#= name #>_EVENT,
#else
	0,
	NULL,
#endif
	<#= id #>,
	_T("<#= name #>"),
	_T("<#= e.Attributes["template"].Value #>"),
	<#= name #>_type_list,
	<#= name #>_FieldNames,
<#
	if (timeField) {
	#>
	<#= accro #>_UtcTime,
<#
	} else {
	#>
	NO_FIELD,
<#
	}
	if (e.Attributes["rulename"] != null) {
	#>
	_T("<#= e.Attributes["rulename"].Value #>"),
<#
	} else {
	#>
	NULL,
<#
	}
	if (e.Attributes["ruledefault"] != null) {
	#>
	Rule_<#= e.Attributes["ruledefault"].Value #>,
<#
	} else {
#>
	Rule_exclude,
<#
	}
#>
	<#= name #>_FieldHashes
};
#endif
<#
		
		if (i != "") {
#>
#endif
<#
		}
	}
#>
#define SYSMON_MAX_EVENT_Fields <#= maxfields #>
#define SYSMON_MAX_EVENT_ID <#= maxid #>

#define V_MAJOR(_x) 	((_x >> 16) & 0xFFFF)
#define V_MINOR(_x) 	(_x & 0xFFFF)
#define TO_DOUBLE(_x)	((double)(V_MAJOR(_x)*1.0)+(V_MINOR(_x)*0.01))

#if !defined(SYSMON_EVENT_C)
extern PTCHAR ConfigurationDtdRule;
extern SYSMON_EVENT_TYPE_FMT* AllEvents[];
extern SIZE_T AllEventsCount;
extern PSYSMON_EVENT_TYPE_FMT EventTypesById[];
extern SIZE_T EventTypesByIdCount;
extern const ULONG ConfigurationVersion;
extern const ULONG BinaryVersion;
PTCHAR GetDtdFormat( ULONG version );

#define IsCompatibleVersion(_x) \
	(V_MAJOR(_x) == V_MAJOR(ConfigurationVersion))
#define IsCompatibleBinaryVersion(_x) \
	(V_MAJOR(_x) == V_MAJOR(BinaryVersion))
#else
SYSMON_EVENT_TYPE_FMT* AllEvents[] = {
<#
	foreach (XmlNode e in eventNodes)
	{
		var i = OutputIfDef(e);
		
		if (i != "") {
#>
#if <#= i #>
<#
		}
#>
	&<#= e.Attributes["name"].Value #>_Type,
<#
		
		if (i != "") {
#>
#endif
<#
		}
	}
#>
};

SIZE_T AllEventsCount = _countof(AllEvents);

PSYSMON_EVENT_TYPE_FMT EventTypesById[] = {
<#
	for (int i = 0; i <= maxid; i++) {
		string val = "NULL";
		if (eventIdTableDict.ContainsKey(i)) {
			val = "&" + eventIdTableDict[i] + "_Type";
		}
#>
	<#= val #>, // <#= i #>
<#
	}
#>
};

SIZE_T EventTypesByIdCount = _countof(EventTypesById);

const ULONG ConfigurationVersion = <#= TransformVersion(highest) #>;
const ULONG BinaryVersion = <#= TransformVersion(highestBinary) #>;

PTCHAR
GetDtdFormat(
	ULONG version
	)
{
	PTCHAR ConfigurationDtdRule = NULL;
	
<#
var items = from pair in manDict orderby pair.Key descending select pair;
var filterStrs = new List<string>();
var configurationOptions = new Dictionary<string,string>();
var configurationSwitches = new Dictionary<string,string>();
var configurationCmdLineOnly = new Dictionary<string,string>();
var configurationExclusive = new Dictionary<string,string>();
var configurationOnRule = new Dictionary<string,string>();
var configurationIfDef = new Dictionary<string,string>();
string defaultFilter = "";
var nodePerRuleName = new Dictionary<string,XmlNode>();
foreach (XmlNode en in eventNodes) {
	if (en.Attributes["rulename"] == null) { continue; }
	
	nodePerRuleName[en.Attributes["rulename"].Value] = en;
}

//
// Ensure that the filter options identifiers used in the
// rule binary format are consitent. To do that, create the
// the list of identifiers starting backward.
//
foreach (var manEntry in items.Reverse()) {
	XmlNode m = manEntry.Value;
	var fnode = m.SelectSingleNode(@".//filters");

	// Ensure consistency from binary version from 14.0.
	var b = double.Parse(m.Attributes["binaryversion"].Value);
	if (b < 14.0) {
		continue;
	}

	var l = fnode.InnerText.Split(',');
	foreach(string t in l) {
		if (filterStrs.Contains(t)) { continue; }
		filterStrs.Add(t);
	}
}

foreach (var manEntry in items) {
	var ver = manEntry.Key;
	XmlNode m = manEntry.Value;
	
	if (ver < highest && ver < highestBase) {
		continue;
	}
	
	eventNodes = m.SelectNodes(@".//event");
	
	//
	// Check if it is compatible with the base event nodes
	//
	foreach (XmlNode en in eventNodes) {
		if (en.Attributes["rulename"] == null) { continue; }
		string rn = en.Attributes["rulename"].Value;
		
		if (!nodePerRuleName.ContainsKey(rn))
			throw new Exception("Base does not contain rule named: "+rn);
			
		XmlNode b = nodePerRuleName[rn];
		
		if (((en.Attributes["ruledefault"] != null) != (b.Attributes["ruledefault"] != null)) ||
			(en.Attributes["ruledefault"] != null && en.Attributes["ruledefault"].Value != b.Attributes["ruledefault"].Value))
			throw new Exception("Different rule default for "+rn);
		
		XmlNodeList b_sub = b.SelectNodes(@".//data");
		XmlNodeList sub = en.SelectNodes(@".//data");
		
		/*
		if (sub.Count > b_sub.Count)
		{
			//throw new Exception("More fields in the older type for rule: "+rn);
			Console.WriteLine("Warning skip checking "+rn+" due to less elements in new version");
			continue;
		}
		*/
		
		int diff = 0;
		for(int index = 0; index < sub.Count; index++) {
		
			var sub_item = sub.Item(index);
			var b_sub_item = b_sub.Item(index-diff);
		
			if (b_sub_item.Attributes["name"].Value != sub_item.Attributes["name"].Value)
			{
				Console.WriteLine("Warning skip check of "+sub_item.Attributes["name"].Value+" due to misalignment");
				diff += 1;
				continue;
			}
			
			if (sub_item.OuterXml != b_sub_item.OuterXml)
				throw new Exception("Incompatible rule '"+rn+"' for field '"+sub_item.Attributes["name"].Value+"'");
		}
	}
	
	string cmp = ">=";
	string elseornot = "} else ";
	
	if (ver == highest) {
	
		cmp = "==";
		elseornot = "";
	}
#>
	<#= elseornot #>if( version <#= cmp#> <#= TransformVersion(ver) #> ) {

<#
	Dictionary<string, XmlNode> ruleOptions = new Dictionary<string, XmlNode>();
	DElement root = new DElement("Sysmon");
	root.children.Add(new DAttr("schemaversion", "CDATA #REQUIRED"));
	DElement eventFilter = new DElement("EventFiltering");
	root.children.Add(eventFilter);
	DElement ruleGroup = new DElement("RuleGroup");
	ruleGroup.children.Add(new DAttr("groupRelation", "(and|or) #REQUIRED"));
	ruleGroup.children.Add(new DAttr("name", "CDATA #IMPLIED"));
	eventFilter.children.Add(ruleGroup);
	
	XmlNodeList optionNodes = m.SelectNodes(@".//option");
	foreach (XmlNode o in optionNodes)
	{
		bool isRule = false;
		var n = o.Attributes["name"].Value;
		if (o.Attributes["rule"] != null && o.Attributes["rule"].Value.ToLower() == "true")
		{
			ruleOptions[n] = o;
			isRule = true;
		}
		string val = "(#PCDATA)";
		
		//
		// Identify incompatibility across options
		//
		string co_value = "";
		if (o.Attributes["argument"] == null || o.Attributes["argument"].Value == "none") {
			val = "EMPTY";
			co_value = "ConfigNoValue";
		} else if (o.Attributes["argument"].Value == "optional") {
			co_value = "ConfigValueOptional";
		} else if (o.Attributes["argument"].Value == "required") {
			co_value = "ConfigValueRequired";
		} else {
			throw new Exception("Unknown argument: "+o.Attributes["argument"].Value);
		}
		
		if (configurationOptions.ContainsKey(n)) {
			if (configurationOptions[n] != co_value)
				throw new Exception("(1) Invalid configuration change, not supported with current configuration design for: "+n + "option: "+configurationOptions[n] + " val: "+ co_value);
		} else {
			configurationOptions[n] = co_value;
		}
		
		string co_switch = "";
		if (o.Attributes["switch"] == null || o.Attributes["switch"].Value == "") {
			co_switch = "NULL";
		} else if (o.Attributes["switch"].Value.Length != 0) {
			co_switch = "_T(\""+o.Attributes["switch"].Value+"\")";
		} else {
			throw new Exception("Incorrect switch: "+o.Attributes["switch"].Value);
		}
		
		if (co_switch != "NULL" && configurationSwitches.ContainsKey(n)) {
			if (configurationSwitches[n] != co_switch)
				throw new Exception("(2) Invalid configuration change, not supported with current configuration design for: "+n +" switch:" + co_switch);
		} else {
			configurationSwitches[n] = co_switch;
		}
		
		string excl = "FALSE";
		if (o.Attributes["exclusive"] != null && o.Attributes["exclusive"].Value == "true") {
			excl = "TRUE";
		}
		
		if (configurationExclusive.ContainsKey(n)) {
			if (configurationExclusive[n] != excl)
				throw new Exception("(3) Invalid configuration change, not supported with current configuration design for: "+n);
		} else {
			configurationExclusive[n] = excl;
		}
		
		var onrule = "FALSE";
		if (isRule) {
			onrule = "TRUE";
		}
		
		if (configurationOnRule.ContainsKey(n)) {
			if (configurationOnRule[n] != onrule)
				throw new Exception("(4) Invalid configuration change, not supported with current configuration design for: "+n);
		} else {
			configurationOnRule[n] = onrule;
		}
		
		string cmdlineonly = "FALSE";
		if (o.Attributes["noconfig"] != null && o.Attributes["noconfig"].Value == "true") {
			cmdlineonly = "TRUE";
		}
		
		if (configurationCmdLineOnly.ContainsKey(n)) {
			if (configurationCmdLineOnly[n] != cmdlineonly)
				throw new Exception("(5) Invalid configuration change, not supported with current configuration design for: "+n);
		} else {
			configurationCmdLineOnly[n] = cmdlineonly;
		}
		
		var i = OutputIfDef(o);
		
		if (configurationIfDef.ContainsKey(i)) {
			if (configurationIfDef[n] != i)
				throw new Exception("(6) Invalid configuration change, not supported with current configuration design for: "+n);
		} else {
			configurationIfDef[n] = i;
		}
		
		if (cmdlineonly != "TRUE")
		{
			if (!isRule)
			{
				root.children.Add(new DElement(n, val, o));
			}
			else if(o.Attributes["forceconfig"] != null && o.Attributes["forceconfig"].Value == "true")
			{
				root.children.Add(new DElement(n+"Config", val, o));
			}
		}
	}

	DElement ruleType = new DElement("Rule");
	ruleType.children.Add(new DAttr("groupRelation", "CDATA #IMPLIED"));
	ruleType.children.Add(new DAttr("name", "CDATA #IMPLIED"));

	foreach (XmlNode e in eventNodes)
	{
		if (e.Attributes["rulename"] == null) { continue; }
		
		DElement current;
		
		if (eventFilter.children.Any(item => item.name == e.Attributes["rulename"].Value)) {
			current = (DElement)eventFilter.children.First(item => item.name == e.Attributes["rulename"].Value);
		} else {
			current = new DElement(e.Attributes["rulename"].Value, e);
			current.children.Add(new DAttr("onmatch", "(include|exclude) #IMPLIED"));
			current.children.Add(new DAttr("default", "(include|exclude) #IMPLIED"));
			current.children.Add(ruleType);
		
			eventFilter.children.Add(current);
			ruleGroup.children.Add(current);
		}
		XmlNodeList sub = e.SelectNodes(@".//data");
		var fnode = m.SelectSingleNode(@".//filters");
		var f_def = fnode.Attributes["default"].Value;
		if (defaultFilter != "" && defaultFilter != f_def ) {
			throw new Exception("Incorrect default filter, should upgrade major?");
		}
		defaultFilter = f_def;
		foreach(XmlNode s in sub)
		{
			DElement dataElement = new DElement(s.Attributes["name"].Value);
			dataElement.children.Add(new DAttr("condition", String.Format("CDATA \"{0}\"", f_def)));
			dataElement.children.Add(new DAttr("name", "CDATA #IMPLIED"));
			if (!current.children.Any(item => item.name == s.Attributes["name"].Value)) {
				current.children.Add(dataElement);
				ruleType.children.Add(dataElement);
			}
		}
	}
	string pad = "			";
	string padComment = "		// ";
	foreach (string target in DObject.possibleTargets)
	{
	#>
#if <#= OutputIfDefFromTarget(target) #> && !defined(DTD_VER_<#= TransformVersion(ver) #>)
#define DTD_VER_<#= TransformVersion(ver) #>
		// Comment for testing the dtd unprocessed (for <#=target#>):
		// <!DOCTYPE Sysmon [
<#= FormatDtd(root, target, padComment, false) #>
		// ]>
		ConfigurationDtdRule = _T("<!DOCTYPE Sysmon [")
<#= FormatDtd(root, target, pad) #>
			_T("]>\n");
#endif
<#
	}
	
}
#>
	} else {

#if !defined(SYSMON_DRIVER)
		_tprintf( _T("Error: Incorrect or unsupported schema version %.2f. Current Sysmon schema version %.2f\n\n"),
				  TO_DOUBLE(version), TO_DOUBLE(ConfigurationVersion));
#endif
	}
	
	return ConfigurationDtdRule;
}
#endif

//
// Filter options
// Part of the format, always add new entries at the end of the list in the template.
//
<#
filterStrs = filterStrs.ToList();
#>
typedef enum {
<#
	foreach (string f in filterStrs) {
#>
	<#= ToFitlerName(f) #>,
<#
	}
#>
    // As the compiler sizes enums according to the size of the values within them,
    // the inclusion of a 32 bit value will size the enum to 32 bits, and the
    // inclusion of a negative value will make the enum signed.
    //
    // On Windows, positive values >= 0x80000000 (but <= 0xffffffff) will be treated
    // as negative values and the enum will remain as a signed 32 bit value.  On Linux,
    // however, such values will cause the enum to be expanded to a signed 64 bit value.
    //
    // The ramification is that the internal representation of the rules will change
    // due to the expansion of each filter struct by 4 bytes.
    //
    // As such, please don't use values >= 0x80000000 (unless absolutely necessary)
    // to maintain cross-platform compatibility of internal representations, which is
    // tested by the unit tests.
    //
	// Environment variables need to be expanded, set on rule loading.
	Filter_Environment = 0x40000000,
	Filter_Unknown = -1
} FilterOption;

#define FilterValue(_x) (_x & 0xFFFF)

#if !defined(SYSMON_EVENT_C) && !defined(SYSMON_DRIVER)
FilterOption
GetFilterOption(
	const char *value
	);
PTCHAR
GetFilterName(
	FilterOption value
	);
RuleDefaultType
GetRuleDefault(
	const char *value
	);
PTCHAR
GetRuleDefaultName(
	RuleDefaultType value
	);
RuleDefaultType
GetRuleMatch(
	const char *value
	);
PTCHAR
GetRuleMatchName(
	RuleDefaultType value
	);
#define SYSMON_FILTER_CONDITIONS _T("<#= String.Join(", ", filterStrs) #>")
#elif !defined(SYSMON_DRIVER)
FilterOption
GetFilterOption(
	const char *value
	)
{
	if( value == NULL || *value == 0 ) {
	
		return <#= ToFitlerName(defaultFilter) #>;
	}<#
	foreach (string f in filterStrs) {
#> else if( 0 == STRCASECMP( value, "<#= f #>" ) ) {
	
		return <#= ToFitlerName(f) #>;
	}<#
	}
#>

	return Filter_Unknown; 
}
PTCHAR
GetFilterName(
	FilterOption value
	)
{
	switch( value ) {
	<#
	foreach (string f in filterStrs) {
#> case <#= ToFitlerName(f) #>:
		return _T("<#= f #>");
	<#
	}
#>
    default:
        return _T("<#= defaultFilter #>");
	}
}
RuleDefaultType
GetRuleDefault(
	const char *value
	)
{
	if( value == NULL ) {
	
		return Rule_Unknown;
	}
	
	// It is inverted due to change in configuration files
	if( 0 == STRCASECMP( value, "include" ) ) {
	
		return Rule_include;
	} else if( 0 == STRCASECMP( value, "exclude" ) ) {
	
		return Rule_exclude;
	}

	return Rule_Unknown;
}
PTCHAR
GetRuleDefaultName(
	RuleDefaultType value
	)
{
	switch( value ) {
	case Rule_include:
		return _T("include");
	case Rule_exclude:
		return _T("exclude");
    default:
        return _T("?");
	}
}
RuleDefaultType
GetRuleMatch(
	const char *value
	)
{
	if( value == NULL ) {
	
		return Rule_Unknown;
	}
	
	// It is inverted due to change in configuration files
	if( 0 == STRCASECMP( value, "exclude" ) ) {
	
		return Rule_include;
	} else if( 0 == STRCASECMP( value, "include" ) ) {
	
		return Rule_exclude;
	}

	return Rule_Unknown;
}
PTCHAR
GetRuleMatchName(
	RuleDefaultType value
	)
{
	switch( value ) {
	case Rule_include:
		return _T("exclude");
	case Rule_exclude:
		return _T("include");
    default:
        return _T("?");
	}
}
<#
filterStrs = filterStrs.Distinct().ToList();
#>
#endif

//
// Rules structures
//
#pragma pack(push)
#pragma pack(1)

typedef struct _RULE_AGGREGATION
{
	WCHAR name[128];						// Optional name. 
	ULONG64	messageId;					// Event sequence number. Used for event correlation during rule matching
	ULONG aggregationId;				// One up correlation ID for matching filter rules
	ULONG rootRuleOffset;				// Offset for the first filter rule in the chain
	ULONG nextOffset;					// Offset for next aggreation item in the chain
	ULONG ruleCount;					// The number of rules in this aggregation	
	RuleCombineType combineType;		// How the rules are combined
	ULONG rulesChecked;					// used by matching routine to record how many filters have been checked
	ULONG rulesMatched;					// used by matching routine to record how many filters have been checked
} RULE_AGGREGATION, *PRULE_AGGREGATION;

typedef struct _RULE_FILTER
{
	ULONG FieldId;
	WCHAR Name[256];
	FilterOption FilterType;
	ULONG NextOffset;
	ULONG DataSize;
	ULONG AggregationId;				// Aggregation ID if this is part of a <Rule>
	ULONG AggregationOffset;			// Offset to the RULE_AGGREGATION if this is a <Rule>		
	UCHAR Data[ANYSIZE_ARRAY];
} RULE_FILTER, *PRULE_FILTER;

typedef struct _RULE_EVENT
{
	ULONG EventId;
	RuleDefaultType RuleDefault;
	RuleCombineType CombineType;
	ULONG NextOffset;
	ULONG FilterCount;
	ULONG FirstFilterOffset;		// Offset of the first RULE_FILTER for this event instance
} RULE_EVENT, *PRULE_EVENT;

typedef struct _RULE_REG
{
	ULONG Version;
	ULONG RuleCount;
} RULE_REG, *PRULE_REG;

typedef struct _RULE_REG_EXT
{
	RULE_REG header;
	ULONG RuleRegSize;
	ULONG SchemaVersion;
	ULONG FirstEventOffset;			// Offset of the first RULE_EVENT
	ULONG FirstAggregationOffset;	// Offset of the first RULE_AGGREGATION
} RULE_REG_EXT, *PRULE_REG_EXT;
#pragma pack(pop)

//
// Configuration structures
//
typedef struct _CONFIGURATION_OPTION
{
	BOOLEAN IsSet;
	PVOID Value;
	ULONG Size;
	BOOLEAN ValueAllocated;
} CONFIGURATION_OPTION, *PCONFIGURATION_OPTION;

typedef struct _CONFIGURATION_OPTIONS
{
<#
	foreach (string k in configurationOptions.Keys)
	{
		var i = configurationIfDef[k];
		
		if (i != "") {
#>
#if <#= i #>
<# 
		}
#>
	CONFIGURATION_OPTION <#= k #>;
<#
		if (i != "") {
#>
#endif
<#
		}
	}
#>
} CONFIGURATION_OPTIONS, *PCONFIGURATION_OPTIONS;

typedef enum {
	ConfigNoValue,
	ConfigValueRequired,
	ConfigValueOptional,
} ConfigType;

typedef struct _CONFIGURATION_OPTION_TYPE
{
	BOOLEAN CommandLineOnly;
	BOOLEAN Exclusive;
	BOOLEAN OnRule;
	PTCHAR FieldName;
	SIZE_T FieldNameCch;
	PTCHAR Switch;
	ConfigType ValueFlag;
	PCONFIGURATION_OPTION Option;
} CONFIGURATION_OPTION_TYPE, *PCONFIGURATION_OPTION_TYPE;

#define OPT_DATA(_x)  (ConfigOptions._x)
#define OPT_SET(_x)   (OPT_DATA(_x).IsSet)
#define OPT_SIZE(_x)  (OPT_DATA(_x).Size)
#define OPT_VALUE(_x) ((OPT_SET(_x) && OPT_SIZE(_x) != 0) ? (OPT_DATA(_x).Value) : NULL)

#if !defined(SYSMON_EVENT_C)
extern CONFIGURATION_OPTIONS ConfigOptions;
extern CONFIGURATION_OPTION_TYPE ConfigOptionType[];
extern SIZE_T ConfigOptionTypeCount;
#else
CONFIGURATION_OPTIONS ConfigOptions = {0,};
CONFIGURATION_OPTION_TYPE ConfigOptionType[] = {
<#
	foreach (KeyValuePair<string,string> co in configurationOptions)
	{
		var i = configurationIfDef[co.Key];
		
		if (i != "") {
#>
#if <#= i #>
<# 
		}
#>
	{ <#= configurationCmdLineOnly[co.Key] #>, <#= configurationExclusive[co.Key] #>, <#= configurationOnRule[co.Key] #>, _T("<#= co.Key #>"), <#= co.Key.Length #>, <#= configurationSwitches[co.Key] #>, <#= co.Value #>, &ConfigOptions.<#= co.Key #> },
<#
		if (i != "") {
#>
#endif
<#
		}
	}
#>
};
SIZE_T ConfigOptionTypeCount = _countof(ConfigOptionType);
#endif
<#
} else if (type == "mc") { #>
;//Copyright (c) 1992, 1993  Microsoft Corporation
;//
;//Module Name:
;//
;//  Status values are 32 bit values layed out as follows:
;//
;//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
;//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
;//  +---+-+-------------------------+-------------------------------+
;//  |Sev|C|       Facility          |               Code            |
;//  +---+-+-------------------------+-------------------------------+
;//
;//  where
;//
;//      Sev - is the severity code
;//
;//          00 - Success
;//          01 - Informational
;//          10 - Warning
;//          11 - Error
;//
;//      C - is the Customer code flag
;//
;//      Facility - is the facility code
;//	
;//      Code - is the facility's status code
;//
;
MessageIdTypedef=NTSTATUS

SeverityNames=(Success=0x0:STATUS_SEVERITY_SUCCESS
               Informational=0x1:STATUS_SEVERITY_INFORMATIONAL
               Warning=0x2:STATUS_SEVERITY_WARNING
               Error=0x3:STATUS_SEVERITY_ERROR
              )

FacilityNames=(System=0x0
               RpcRuntime=0x2:FACILITY_RPC_RUNTIME
               RpcStubs=0x3:FACILITY_RPC_STUBS
               Io=0x4:FACILITY_IO_ERROR_CODE
               Serial=0x6:FACILITY_SERIAL_ERROR_CODE
              )
<#  
	foreach (XmlNode e in eventNodes)
	{
		if (Skip(e)) { continue; }
		
		string sev = e.Attributes["level"].Value;
		
		int val = (int)new System.ComponentModel.Int32Converter().ConvertFromString(e.Attributes["value"].Value);
#>
MessageId=0x<#= String.Format("{0:X}", val) #> Facility=Serial Severity=<#= sev #> SymbolicName=<#= e.Attributes["name"].Value #>
Language=English
<#= e.Attributes["template"].Value #>:<#
	XmlNodeList sub = e.SelectNodes(@".//data");
	int i = 1;
	foreach(XmlNode s in sub)
	{
#>%n
  <#= s.Attributes["name"].Value #>: %<#= i++ #>!s!<#
	}
#>

.

<#
	}
} else if( type == "schema" ) {#>
    <# foreach ( XmlNode schemaMan in manDict.Values ) { 
		string output = GenerateTargetManifestXml( schemaMan ); #>
		<#= output #>
	<# } #>
<#
} else if( type == "man" ) {#>
<?xml version="1.0" encoding="UTF-16"?>
<instrumentationManifest xsi:schemaLocation="http://schemas.microsoft.com/win/2004/08/events eventman.xsd" xmlns="http://schemas.microsoft.com/win/2004/08/events" xmlns:win="http://manifests.microsoft.com/win/2004/08/windows/events" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:trace="http://schemas.microsoft.com/win/2004/08/events/trace">
	<instrumentation>
		<events>
<#
if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Windows)) {
#>
			<provider name="Microsoft-Windows-Sysmon" guid="{5770385F-C22A-43E0-BF4C-06F5698FFBD9}" symbol="SYSMON_PROVIDER" resourceFileName="%filename%" messageFileName="%filename%">
<#
} else if (System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(System.Runtime.InteropServices.OSPlatform.Linux)) {
#>
			<provider name="Linux-Sysmon" guid="{FF032593-A8D3-4F13-B0D6-01FC615A0F97}" symbol="SYSMON_PROVIDER" resourceFileName="%filename%" messageFileName="%filename%">
<#
}
#>
				<events>
<#  
	foreach (XmlNode e in eventNodes)
	{
		if (Skip(e)) { continue; }
		
		string name = e.Attributes["name"].Value;
		int val = (int)new System.ComponentModel.Int32Converter().ConvertFromString(e.Attributes["value"].Value);
#>
					<event symbol="<#= name #>_EVENT" value="<#= val.ToString() #>" version="<#= e.Attributes["version"].Value #>" channel="Microsoft-Windows-Sysmon/Operational" level="win:<#= e.Attributes["level"].Value #>" task="SysmonTask-<#= name #>" opcode="win:Info" template="<#= e.Attributes["template"].Value #>" message="$(string.event.str_<#= name #>)" />
<#
	}
#>
				</events>
				<levels>
				</levels>
				<tasks>
<#  
	foreach (XmlNode e in eventNodes)
	{
		if (Skip(e)) { continue; }
		
		string name = e.Attributes["name"].Value;
		int val = (int)new System.ComponentModel.Int32Converter().ConvertFromString(e.Attributes["value"].Value);
#>
					<task name="SysmonTask-<#= name #>" symbol="SYSMON_TASK_<#= name #>" value="<#= val #>" message="$(string.task.<#= name #>)" eventGUID="{C511FFB3-9FBF-45F5-A97B-9BEE<#= val.ToString("X8") #>}" />
<#
	}
#>
				</tasks>
				<opcodes>
				</opcodes>
				<channels>
					<channel name="Microsoft-Windows-Sysmon/Operational" chid="c1" symbol="SYSMON_CHANNEL" type="Operational" enabled="true"
						isolation="Custom" access="O:BAG:SYD:(A;;0xf0007;;;SY)(A;;0x7;;;BA)(A;;0x1;;;BO)(A;;0x1;;;SO)(A;;0x1;;;S-1-5-32-573)">
						<logging><maxSize>67108864</maxSize></logging>
					</channel>
				</channels>
				<templates>
<#
	foreach (XmlNode e in eventNodes)
	{
		if (Skip(e)) { continue; }
#>
					<template tid="<#= e.Attributes["template"].Value #>">
<#
	XmlNodeList sub = e.SelectNodes(@".//data");
	foreach(XmlNode s in sub)
	{
#>
						<data name="<#= s.Attributes["name"].Value #>" inType="<#= s.Attributes["inType"].Value #>"<# if (s.Attributes["outType"] != null) { #> outType="<#= s.Attributes["outType"].Value #>"<# } #> />
<#
	}
#>
					</template>
<#
	}
#>
				</templates>
			</provider>
		</events>
	</instrumentation>
	<localization>
		<resources culture="en-US">
			<stringTable>
				<string id="opcode.Info" value="Info" />
				<string id="level.Informational" value="Information" />
				<string id="level.Error" value="Error" />
<#
	foreach (XmlNode e in eventNodes)
	{
		if (Skip(e)) { continue; }

		var task = e.Attributes["template"].Value;
		
		if (e.Attributes["rulename"] != null) { task += " (rule: "+e.Attributes["rulename"].Value+")"; }

#>
				<string id="task.<#= e.Attributes["name"].Value #>" value="<#= task #>" />
				<string id="event.str_<#= e.Attributes["name"].Value #>" value="<#= e.Attributes["template"].Value #>:<#
		XmlNodeList sub = e.SelectNodes(@".//data");
		int i = 1;
		foreach(XmlNode s in sub)
		{
#>%n<#= s.Attributes["name"].Value #>: %<#= i++ #>!s!<#
		}
#>" />
<#
	}
#>
			</stringTable>
		</resources>
	</localization>
</instrumentationManifest>
<# 
}
#>
<#+

	public void CopyTargetFilteredDocument( XmlDocument doc, XmlNode dstParent, XmlNode src )
	{
		if( src.Attributes == null || !Skip( src )) {
	
			XmlNode dst = doc.ImportNode( src, false );

			// Remove target attribute
			if( dst.Attributes != null ) {
				XmlAttribute targetAttr = dst.Attributes["target"];
				if( targetAttr != null ) {
			
					dst.Attributes.Remove(targetAttr);
				}
			}
			dstParent.AppendChild( dst );
			if( src.HasChildNodes ) {
			
				foreach (XmlNode child in src.ChildNodes ) {
				
					CopyTargetFilteredDocument( doc, dst, child );
				}
			}
		}
	}

	public string GenerateTargetManifestXml( XmlNode node )
	{
		XmlDocument doc = new XmlDocument();
		
		// Copy the target schema
		CopyTargetFilteredDocument( doc, doc, node );

		// Pretty print it
		StringBuilder sb = new StringBuilder();
		XmlWriterSettings settings = new XmlWriterSettings
		{
			Indent = true,
			IndentChars = "  ",
			NewLineChars = "\n",
			NewLineHandling = NewLineHandling.Replace
		};
		using (XmlWriter writer = XmlWriter.Create(sb, settings)) {
			doc.Save(writer);
		}
		return sb.ToString();
	}

	public bool Skip(XmlNode e)
	{
		var t = e.Attributes["target"];
		if (t != null) {
			List<string> targets = new List<string>(t.Value.ToLower().Split(','));
			string version = Host.ResolveParameterValue("", "", "version");
			
			if (targets.Count > 0 && !targets.Contains("all") && !targets.Contains(version)) {
				return true;
			}
		}
		
		return false;
	}
	
	public string OutputIfDefFromTarget(string target)
	{
		string t = target.ToLower();
		List<string> targets = new List<string>(t.Split(','));
		
		var val = "";
		if (!targets.Contains("all")) {
			
			if (t == "internal")
				val = "!defined(SYSMON_SHARED) && !defined(SYSMON_PUBLIC)";
			else if (t == "shared")
				val = "defined(SYSMON_SHARED)";
			else if (targets.Contains("internal") && targets.Contains("shared"))
				val = "!defined(SYSMON_PUBLIC)";
			else if (t == "public")
				val = "defined(SYSMON_PUBLIC)";
			
			if (val == "")
				throw new Exception("Unknown type: "+target);
		}
		return val;
	}
	
	public string OutputIfDef(XmlNode e)
	{
		var t = e.Attributes["target"];
		if (t != null) {
			return OutputIfDefFromTarget(t.Value);
		}
		return "";
	}
	
	public string GetAcro(XmlNode e)
	{
		var startwith = "SYSMONEVENT_";
		var name = e.Attributes["name"].Value;
		
		if (!name.StartsWith(startwith))
			throw new Exception("Incorrect name: "+name);
		
		name = name.Substring(startwith.Length);
		List<string> n = new List<string>(name.ToUpper().Split('_'));
		var ret = "";
		foreach (var x in n) {
			ret += x[0];
		}
		return "F_"+ret;
	}
	
	public string GetInType(XmlNode e)
	{
		var s_intype = e.Attributes["inType"].Value;
		var winstart = "win:";
		if (s_intype.StartsWith(winstart))
			s_intype = s_intype.Substring(winstart.Length);
		return s_intype;
	}
	
	public string TransformVersion(double f)
	{
		string v = f.ToString("0.00");
		string[] s = v.Split('.');
		int a = int.Parse(s[0]);
		int b = int.Parse(s[1]);
		var x = string.Format("0x{0}{1}", a.ToString("X4"), b.ToString("X4"));
		return x;
	}
	
	public string ToFitlerName(string s)
	{
		return String.Format("Filter_{0}", s.Replace(" ", "_"));
	}
	
	public abstract class DObject
	{
		public string name;
		protected string[] targets;
		public static string[] possibleTargets = new string[] { "internal", "shared", "public" };
		
		public DObject(XmlNode o, string objectName, bool targetRequired=false)
		{
			name = objectName;
			targets = null;
			
			if (o == null)
				return;
			
			var t = o.Attributes["target"];
			if (t != null) {
				targets = (new List<string>(t.Value.ToLower().Split(','))).ToArray();
				
				if (targets.Count() == 0)
					throw new Exception(String.Format("Empty target on {0}", o));
					
				foreach (string s in targets)
				{
					if (s == "all")
					{
						targets = possibleTargets;
						break;
					}
					
					if (!possibleTargets.Contains(s))
					{
						throw new Exception(String.Format("Unknown target {0} for {1}", s, o));
					}
				}
			}
			else if (targetRequired)
			{
				throw new Exception(String.Format("No target when expected on {0}", o));
			}
		}
		
		public bool IsIncluded(string target)
		{
			if (targets == null)
				return true;
			return targets.Contains(target);
		}
		
		protected string ItemFormat(string element, string name, string data)
		{
			return String.Format("<!{0} {1} {2}>", element, name, data);
		}
		
		public abstract List<string> GenerateDtd(string target, DObject parent=null);
	};
	
	public class DAttr : DObject
	{
		string data;
	
		public DAttr(string attName, string attData, XmlNode o=null) : base(o, attName)
		{
			data = attData;
		}
		
		public override List<string> GenerateDtd(string target, DObject parent=null)
		{
			return new List<string>() { ItemFormat("ATTLIST", parent.name, name+" "+data) };
		}
	};
	
	public class DElement : DObject
	{
		string data = null;
		public List<DObject> children = new List<DObject>();
		
		public DElement(string elementName, string elementData, XmlNode o=null) : base(o, elementName, true)
		{
			name = elementName;
			data = elementData;
		}
		
		public DElement(string elementName, XmlNode o=null) : base(o, elementName, true)
		{
		}
		
		public override List<string> GenerateDtd(string target, DObject parent=null)
		{
			if (data != null)
			{
				return new List<string>() { ItemFormat("ELEMENT", name, data) };
			}
			
			if (children.Count == 0)
				throw new Exception(String.Format("Element {0} without data or children?", name));
			
			List<string> elements = new List<string>();
			List<string> result = new List<string>();
				
			foreach (DObject o in children)
			{
				if (!o.IsIncluded(target))
					continue;
					
				if (o is DElement)
				{
					elements.Add(o.name);
				}
				
				result.AddRange(o.GenerateDtd(target, this));
			}
			
			if (elements.Count == 0)
			{
				elements.Insert(0, "#PCDATA");
			}
			
			result.Insert(0, ItemFormat("ELEMENT", name, String.Format("({0})*", String.Join("|", elements))));
			return result.Distinct().ToList();
		}
	};
	
	public string FormatDtdTransform(string line, string padding)
	{
		line.Replace("\"", "\\\"");
		return String.Format("{0}_T(\"{1}\")", padding, line.Replace("\"", "\\\""));
	}
	
	public string FormatDtd(DElement root, string target, string padding, bool transform=true)
	{
		string result = "";
		List<string> lines = root.GenerateDtd(target);
		foreach (string line in lines)
		{
			if (result != "")
				result += System.Environment.NewLine;
				
			if (transform)
			{
				result += FormatDtdTransform(line, padding);
			}
			else
			{
				result += padding + line;
			}
		}
		return result;
	}
#>
